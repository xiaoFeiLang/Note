//
//  GCC.m
//  Note
//
//  Created by loulou on 16/7/1.
//
//

#import <Foundation/Foundation.h>

预编译->编译->汇编->连接

Pre-Processing 预处理阶段(会对各种预处理指令（#include #define #ifdef 等#开始的代码行）进行处理，删除注释和多余的空白字符，生成一份新的代码)
Gcc –E hello.c –o hello.i

Compiling 编译阶段 －－ 接下来进行的是编译阶段，在这个阶段中，Gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言。用户可以使用”-S”选项来进行查看，该选项只进行编译而不进行汇编，生成汇编代码。(对代码进行语法、语义分析和错误判断，生成汇编代码文件)
Gcc –S hello.i –o hello.s  (a.out?)

Assembing 汇编阶段－－把编译阶段生成的”.s”文件转成目标文件，读者在此可使用选项”-c”就可看到汇编代码已转化为”.o”的二进制目标代码了
 Gcc –c hello.s –o hello.o  (readelf -a hello.o)

Linking 链接阶段（在这个程序中并没有定义”printf”的函数实现，且在预编译中包含进的”stdio.h”中也只有该函数的声明，而没有定义函数的实现，那么，是在哪里实现”printf”函数的呢？最后的答案是：系统把这些函数实现都被做到名为libc.so.6的库文件中去了，在没有特别指定时，Gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf”了，而这也就是链接的作用。函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为”.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为”.so”，如前面所述的libc.so.6就是动态库。Gcc在编译时默认使用动态库。）(通俗的讲就是把多个*.o文件合并成一个可执行文件，二进制指令文件)
Gcc hello.o –o hello  (objdump -d hello)

运行
 ./hello


一般生成可执行程序，可以直接 ： gcc  hello.c  -o  hello